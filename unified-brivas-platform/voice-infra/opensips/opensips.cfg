####### OpenSIPS Class 5 Softswitch Configuration #######
#
# Core SIP routing, LCR, fraud detection, and STIR/SHAKEN
#

####### Global Parameters #######

debug_mode=no
log_level=3
log_stderror=no
log_facility=LOG_LOCAL0

fork=yes
children=16
auto_scaling_profile = AGGRESSIVE

# Listen interfaces (internal from SBC)
listen=udp:0.0.0.0:5080
listen=tcp:0.0.0.0:5080

####### Modules Section #######

loadmodule "signaling.so"
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "sipmsgops.so"
loadmodule "mi_fifo.so"
loadmodule "dialog.so"
loadmodule "drouting.so"
loadmodule "load_balancer.so"
loadmodule "fraud_detection.so"
loadmodule "cachedb_local.so"
loadmodule "db_postgres.so"
loadmodule "avpops.so"
loadmodule "acc.so"
loadmodule "mid_registrar.so"

# STIR/SHAKEN (conditional - only for Ashburn)
# loadmodule "stir_shaken.so"
# loadmodule "identity.so"

####### Module Parameters #######

# MI FIFO for management
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")

# Transaction module
modparam("tm", "fr_timeout", 5)
modparam("tm", "fr_inv_timeout", 30)

# Dialog module for call tracking
modparam("dialog", "db_mode", 1)
modparam("dialog", "db_url", "postgres://brivas:password@lumadb:5432/dialogs")
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "default_timeout", 3600)

# Dynamic Routing (LCR)
modparam("drouting", "db_url", "postgres://brivas:password@lumadb:5432/routing")
modparam("drouting", "rule_prefix_avp", "$avp(dr_prefix)")
modparam("drouting", "carrier_id_avp", "$avp(carrier_id)")
modparam("drouting", "ruri_avp", "$avp(dr_ruri)")

# Load Balancer (to FreeSWITCH media servers)
modparam("load_balancer", "db_url", "postgres://brivas:password@lumadb:5432/load_balancer")
modparam("load_balancer", "probing_interval", 30)
modparam("load_balancer", "probing_method", "OPTIONS")

# Fraud Detection
modparam("fraud_detection", "db_url", "postgres://brivas:password@lumadb:5432/fraud")

# Accounting (CDRs)
modparam("acc", "db_url", "postgres://brivas:password@lumadb:5432/cdrs")
modparam("acc", "db_flag", "1")
modparam("acc", "db_missed_flag", "2")
modparam("acc", "cdr_flag", "3")
modparam("acc", "db_extra", "src=$fU;dst=$rU;src_ip=$si")

# Local cache
modparam("cachedb_local", "cachedb_url", "local://")

####### Routing Logic #######

route {
    # Max forwards check
    if (!mf_process_maxfwd_header(10)) {
        send_reply(483, "Too Many Hops");
        exit;
    }
    
    # Record route for dialogs
    if (!is_method("REGISTER|MESSAGE")) {
        record_route();
    }
    
    # Handle sequential requests (in-dialog)
    if (has_totag()) {
        if (loose_route()) {
            if (is_method("BYE")) {
                setflag(3); # CDR flag
                do_accounting("db", "cdr");
            }
            route(RELAY);
        } else {
            if (is_method("ACK")) {
                if (!t_check_trans()) {
                    send_reply(404, "Not Found");
                }
            }
            send_reply(404, "Not Found");
        }
        exit;
    }
    
    # CANCEL handling
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            t_relay();
        }
        exit;
    }
    
    t_check_trans();
    
    # REGISTER handling
    if (is_method("REGISTER")) {
        route(REGISTER);
        exit;
    }
    
    # INVITE handling
    if (is_method("INVITE")) {
        # Create dialog for tracking
        create_dialog();
        setflag(3); # CDR flag
        
        # Fraud detection
        if (!check_fraud("$fU", "$rU")) {
            xlog("L_ALERT", "FRAUD DETECTED: $fU -> $rU from $si\n");
            send_reply(403, "Forbidden - Fraud Detected");
            exit;
        }
        
        # STIR/SHAKEN verification (if enabled)
        # Uncomment for Ashburn PoP
        # if ($hdr(Identity) != null) {
        #     $var(ret) = stir_shaken_verify();
        #     if ($var(ret) < 0) {
        #         xlog("L_WARN", "STIR/SHAKEN verification failed for $fU\n");
        #     }
        # }
        
        # Route via LCR
        route(DROUTING);
        exit;
    }
    
    # Other methods
    route(RELAY);
}

route[REGISTER] {
    # Simple registration handling
    mid_registrar_save("location");
    exit;
}

route[DROUTING] {
    # Least Cost Routing
    if (!do_routing("0")) {
        xlog("L_ERR", "No route found for $rU\n");
        send_reply(404, "No Route");
        exit;
    }
    
    xlog("L_INFO", "Routing $rU via carrier $avp(carrier_id)\n");
    
    # Check if IVR destination
    if ($rU =~ "^ivr-.*") {
        route(IVR);
        exit;
    }
    
    # Check if flash call
    if ($rU =~ "^flash-.*") {
        route(FLASH_CALL);
        exit;
    }
    
    route(RELAY);
}

route[IVR] {
    # Load balance to FreeSWITCH for IVR
    if (!lb_start("1", "ivr")) {
        send_reply(503, "IVR Service Unavailable");
        exit;
    }
    
    xlog("L_INFO", "Routing to FreeSWITCH IVR: $du\n");
    route(RELAY);
}

route[FLASH_CALL] {
    # Flash calls - very short timeout
    $var(timeout) = 2;
    
    # Load balance to FreeSWITCH
    if (!lb_start("1", "flash")) {
        send_reply(503, "Flash Call Service Unavailable");
        exit;
    }
    
    t_set_fr(0, $var(timeout) * 1000);
    route(RELAY);
}

route[RELAY] {
    if (is_method("INVITE")) {
        t_on_failure("MANAGE_FAILURE");
    }
    
    if (!t_relay()) {
        sl_reply_error();
    }
}

failure_route[MANAGE_FAILURE] {
    if (t_is_canceled()) {
        exit;
    }
    
    # Try next carrier/gateway from LCR
    if (use_next_gw()) {
        xlog("L_INFO", "Failover to next gateway for $rU\n");
        t_on_failure("MANAGE_FAILURE");
        t_relay();
        exit;
    }
    
    send_reply(503, "Service Unavailable");
}

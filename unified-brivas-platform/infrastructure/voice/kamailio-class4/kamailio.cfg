#!KAMAILIO
#
# Class 4 SBC Configuration for Brivas Unified Platform
# Carrier-grade voice interconnect with LCR, failover, and CDR
#

####### Global Parameters #######

debug=2
log_stderror=no
log_facility=LOG_LOCAL0

fork=yes
children=16
async_workers=8

# Memory allocation
shm_mem_size=256
pkg_mem_size=32

# Bind addresses (configured via environment)
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060
listen=tls:0.0.0.0:5061

# TLS settings
enable_tls=yes
tls_certificate="/etc/kamailio/tls/server.pem"
tls_private_key="/etc/kamailio/tls/server.key"
tls_ca_list="/etc/kamailio/tls/ca.pem"

# SIP parameters
auto_aliases=no
dns=no
rev_dns=no

####### Modules Section #######

loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "acc.so"
loadmodule "dialog.so"
loadmodule "htable.so"
loadmodule "auth.so"
loadmodule "dispatcher.so"
loadmodule "nathelper.so"
loadmodule "rtpproxy.so"
loadmodule "uac.so"
loadmodule "registrar.so"
loadmodule "usrloc.so"
loadmodule "permissions.so"
loadmodule "avpops.so"
loadmodule "regex.so"
loadmodule "drouting.so"
loadmodule "cnxcc.so"

# Database module for LumaDB (PostgreSQL wire protocol)
loadmodule "db_postgres.so"

####### Module Parameters #######

# Transaction module
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# Record-route module
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# Dialog module for CDR generation
modparam("dialog", "db_mode", 1)
modparam("dialog", "db_url", "postgres://brivas:password@lumadb:5432/brivas_voice")
modparam("dialog", "table_name", "dialogs")
modparam("dialog", "dlg_match_mode", 1)

# Accounting for CDR
modparam("acc", "db_flag", 1)
modparam("acc", "db_missed_flag", 2)
modparam("acc", "db_url", "postgres://brivas:password@lumadb:5432/brivas_voice")
modparam("acc", "db_table_acc", "cdrs")
modparam("acc", "db_table_missed_calls", "missed_calls")
modparam("acc", "cdr_enable", 1)
modparam("acc", "log_extra", "src=$si;dst=$rU;callid=$ci")

# Dispatcher for carrier load balancing
modparam("dispatcher", "db_url", "postgres://brivas:password@lumadb:5432/brivas_voice")
modparam("dispatcher", "table_name", "carrier_gateways")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dst_avp", "$avp(ds_dst)")
modparam("dispatcher", "grp_avp", "$avp(ds_grp)")
modparam("dispatcher", "cnt_avp", "$avp(ds_cnt)")
modparam("dispatcher", "dstid_avp", "$avp(ds_dstid)")

# Dynamic Routing (LCR)
modparam("drouting", "db_url", "postgres://brivas:password@lumadb:5432/brivas_voice")
modparam("drouting", "ruri_avp", "$avp(dr_ruri)")
modparam("drouting", "gw_id_avp", "$avp(dr_gw)")
modparam("drouting", "rule_id_avp", "$avp(dr_rule)")
modparam("drouting", "routing_table_cache", 1)

# RTPProxy for media relay
modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:7722")

# Hash table for rate limiting
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
modparam("htable", "htable", "ratelimit=>size=10;autoexpire=1;")

# Credit control
modparam("cnxcc", "redis", "addr=lumadb;port=6379;db=0")

####### Routing Logic #######

# Main SIP Request Routing
request_route {
    # Per-request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    # Authentication for carriers
    if (!is_method("REGISTER|OPTIONS")) {
        if (!allow_source_address("trusted_peers")) {
            route(AUTH);
        }
    }

    # Record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # OPTIONS ping response
    if (is_method("OPTIONS")) {
        sl_send_reply("200", "OK");
        exit;
    }

    # Handle INVITE - Main call routing
    if (is_method("INVITE")) {
        route(INVITE_ROUTE);
        exit;
    }

    # Handle REGISTER (if acting as registrar)
    if (is_method("REGISTER")) {
        route(REGISTER);
        exit;
    }
}

# Initial request check
route[REQINIT] {
    # Max forwards check
    if(!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    # Sanity check
    if(!sanity_check("17895", "7")) {
        xlog("L_WARN", "Malformed SIP from $si:$sp\n");
        exit;
    }

    # Rate limiting
    if ($sht(ratelimit=>$si) > 100) {
        xlog("L_WARN", "Rate limit exceeded for $si\n");
        $sht(ipban=>$si) = 1;
        exit;
    }
    $sht(ratelimit=>$si) = $sht(ratelimit=>$si) + 1;

    # IP ban check
    if ($sht(ipban=>$si) != $null) {
        xlog("L_WARN", "Blocked IP $si\n");
        exit;
    }
}

# Authentication route
route[AUTH] {
    if (!is_ip_registered($si)) {
        if (!proxy_authorize("", "subscriber")) {
            proxy_challenge("", "0");
            exit;
        }
        consume_credentials();
    }
}

# Within dialog route
route[WITHINDLG] {
    if (!has_totag()) return;

    if (loose_route()) {
        if (is_method("BYE")) {
            route(ACC_CDR);
        }
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if (t_check_trans()) {
            route(RELAY);
            exit;
        }
        exit;
    }

    sl_send_reply("404", "Not Found");
    exit;
}

# INVITE routing - LCR and carrier selection
route[INVITE_ROUTE] {
    # Extract destination number
    $var(called) = $rU;

    # CLI manipulation
    route(CLI_MANIPULATION);

    # Number portability lookup
    route(MNP_LOOKUP);

    # Toll-free number handling
    if ($var(called) =~ "^1800|^1300|^0800") {
        route(TOLLFREE_ROUTE);
        exit;
    }

    # LCR routing
    if (!do_routing("0")) {
        xlog("L_ERR", "No route found for $var(called)\n");
        sl_send_reply("404", "No Route");
        exit;
    }

    # Start dialog tracking for CDR
    dlg_manage();
    setflag(1);  # Enable CDR

    # Failover configuration
    t_on_failure("CARRIER_FAILOVER");

    # Send to first carrier
    route(RELAY);
}

# Toll-free routing
route[TOLLFREE_ROUTE] {
    xlog("L_INFO", "Toll-free call to $var(called)\n");
    
    # Look up toll-free owner in LumaDB
    # TODO: Query brivas_voice.tollfree_numbers table

    route(RELAY);
}

# CLI manipulation
route[CLI_MANIPULATION] {
    # Strip leading zeros
    if ($fU =~ "^0") {
        $fU = $(fU{s.substr,1,0});
    }

    # Add country code if missing
    if ($fU !~ "^\+") {
        # Default to Nigeria country code
        $fU = "+234" + $fU;
    }

    # Update From header
    uac_replace_from("", "sip:$fU@$fd");
}

# MNP lookup
route[MNP_LOOKUP] {
    # Query number portability database
    # TODO: ENUM query or direct LumaDB lookup for ported numbers
    
    xlog("L_DBG", "MNP lookup for $var(called)\n");
}

# Carrier failover on failure
failure_route[CARRIER_FAILOVER] {
    if (t_is_canceled()) {
        exit;
    }

    if (t_check_status("5[0-9][0-9]|408|503")) {
        xlog("L_WARN", "Carrier failed, trying next route\n");
        
        # Try next route in LCR list
        if (next_routing()) {
            t_on_failure("CARRIER_FAILOVER");
            route(RELAY);
            exit;
        }
    }

    # All routes failed
    xlog("L_ERR", "All carrier routes exhausted for call $ci\n");
}

# NAT detection
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(5);  # NAT flag
    }
}

# Relay route
route[RELAY] {
    # Enable RTP proxy for NAT traversal
    if (isflagset(5)) {
        rtpproxy_manage("co");
    }

    if (is_method("INVITE")) {
        t_set_fr(0, 120000);
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# CDR generation
route[ACC_CDR] {
    xlog("L_INFO", "CDR: $ci from $fU to $rU duration=$DLG_lifetime\n");
    acc_db_request("cdr");
}

# Registration handling
route[REGISTER] {
    if (!proxy_authorize("", "subscriber")) {
        proxy_challenge("", "0");
        exit;
    }
    consume_credentials();

    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}
